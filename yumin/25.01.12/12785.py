# 전형적인 DP 문제
# 조건에 따라 점화식을 잘 설정해주면 숭숭 풀리게 된다.

w, h = map(int, input().split())
x, y = map(int, input().split())

x -= 1 # 리스트 조작을 편하게 하기 위해 x와 y를 각각 1씩 빼주자.
y -= 1

dp = [[0] * w for _ in range(h)]
dp[0][0] = 1 # (0, 0)은 무조건 거치므로 1을 넣어주자.

for i in range(y + 1): # (0, 0)부터 (x, y)까지의 경로 탐색
    for j in range(x + 1):
        if i > 0: # 현재 내가 위치해 있는 y 좌표가 0보다 크다면, 그 방향으로 움직인 것이므로, 점화식 계산을 해주자
            dp[i][j] += dp[i - 1][j]
        if j > 0: # 현재 내가 위치해 있는 x 좌표가 0보다 크다면, 그 방향으로 움직인 것이므로, 점화식 계산을 해주자
            dp[i][j] += dp[i][j - 1]

for i in range(y, h): # (x, y)부터 (w, h)까지의 경로 탐색
    for j in range(x, w):
        if i > y: # 위와 동일한 계산
            dp[i][j] += dp[i - 1][j]
        if j > x: # 위와 동일한 계산
            dp[i][j] += dp[i][j - 1]

print(dp[-1][-1] % 1000007) # 최종적으로 계산된 값을 출력

# [예시]
# 입력값이 문제에 나와있는 것과 같을 때, 위의 dp 리스트를 행렬로 나타내면 아래와 같은 모양이 나오게 된다.

'''
[초기값]
1 0 0
0 0 0

[(0, 0) -> (1, 1) 경로 계산 후]
1 1 0
1 2 0

[(1, 1) -> (1, 2) 경로 계산 후]
1 1 0
1 2 2

따라서 출력값은 2가 나오게 된다.
'''
